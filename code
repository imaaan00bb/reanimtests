-- Define constants for easier updates
local r = math.rad
local limbs = {
    ["Left Arm"] = {"Extra Left hand (Blocky)_white", CFrame.Angles(0, 0, r(90))},
    ["Right Arm"] = {"Extra Right hand (Blocky)_white", CFrame.Angles(0, 0, r(90))},
    ["Right Leg"] = {"MeshPartAccessory", CFrame.Angles(0, 0, r(90))},
    ["Left Leg"] = {"Unloaded head", CFrame.Angles(0, 0, r(90))},
    ["Torso"] = {"Front", CFrame.new(0, 0, 0)},
    ["Head"] = {"Face Behind Head_white", CFrame.new(0, 0, 0)},
}

local players = game:GetService("Players")
local p = players.LocalPlayer
local FakeCharacter

-- Helper function to align parts
local function Align(Part1, Part0, CFrameOffset)
    local connection
    connection = game:GetService("RunService").PostSimulation:Connect(function()
        Part1.CFrame = Part0.CFrame * CFrameOffset
    end)

    Part1.Destroying:Connect(function()
        connection:Disconnect()
    end)
    Part0.Destroying:Connect(function()
        connection:Disconnect()
    end)
end

-- Function to handle hat dropping and interaction
local function hatDrop(character)
    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
        animTrack:Stop()
    end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://35154961"
    local loadAnim = character.Humanoid:LoadAnimation(anim)
    loadAnim:Play()
    loadAnim.TimePosition = 3
    loadAnim:AdjustSpeed(0)
    local humanoidRootCFrame = character.HumanoidRootPart.CFrame

    for _, accessory in pairs(character.Humanoid:GetAccessories()) do
        sethiddenproperty(accessory, "BackendAccoutrementState", 0)
        task.delay(1.95, function()
            local connection = game:GetService("RunService").PostSimulation:Connect(function()
                accessory.Handle.AssemblyLinearVelocity = Vector3.new(15, 15, 15)
            end)
            accessory.Handle.Destroying:Connect(function()
                connection:Disconnect()
            end)
        end)
    end

    wait(0.5)
    character.HumanoidRootPart.CFrame *= CFrame.Angles(math.rad(90), 0, 0)
    character.Humanoid:ChangeState(Enum.HumanoidStateType.Physics)

    game:GetService("TweenService"):Create(character.HumanoidRootPart, TweenInfo.new(2, Enum.EasingStyle.Linear), {CFrame = CFrame.new(humanoidRootCFrame.X, -499, humanoidRootCFrame.Z) * CFrame.Angles(math.rad(90), 0, 0)}):Play()

    character.ChildRemoved:Connect(function(v)
        if v:IsA("BasePart") then
            print(v.Name)
        end
    end)

    -- Ensures no movement while the humanoid is being reset
    coroutine.wrap(function()
        while true do
            game:GetService("RunService").PostSimulation:Wait()
            character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
            character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
        end
    end)()

    task.wait(1.95)
    character.Humanoid.Health = 0
end

-- Create and setup the fake character clone
p.Character.Archivable = true
FakeCharacter = p.Character:Clone()

for _, part in ipairs(FakeCharacter:GetDescendants()) do
    if part:IsA("BasePart") then
        part.Transparency = 1
    end
end

FakeCharacter.Parent = workspace
workspace.Camera.CameraSubject = FakeCharacter.Humanoid

game:GetService("RunService").Heartbeat:Connect(function()
    for _, part in pairs(game:GetService("Players").LocalPlayer.Character:GetDescendants()) do
        if part.Name == "Handle" then
            part.Velocity = Vector3.new(999, 999, 999)
        end
    end
end)

-- Remove collisions from all parts in FakeCharacter
game:GetService("RunService").PostSimulation:Connect(function()
    for _, part in ipairs(FakeCharacter:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end)

-- Handle limb adjustments based on the provided limbs table
game:GetService("RunService").PostSimulation:Connect(function()
    for limb, config in pairs(limbs) do
        local name, cf = unpack(config)
        if name ~= "" then
            local part = p.Character:FindFirstChild(name)
            if part then
                coroutine.wrap(function()
                    local success, errorMessage = pcall(function()
                        Align(part.Handle, FakeCharacter[limb], cf)
                    end)
                    if not success then
                        print(errorMessage)
                    end
                end)()
            end
        end
    end
end)

-- Drop hat and perform actions on the character
hatDrop(p.Character)
task.wait(0.2)

-- Repeat limb setup for newly added characters
p.CharacterAdded:Connect(function(character)
    workspace.Camera.CameraSubject = FakeCharacter.Humanoid
    character:WaitForChild("HumanoidRootPart")
    character:WaitForChild("Head")
    workspace.Camera.CameraSubject = FakeCharacter.Humanoid
    wait(0.3)
    hatDrop(character)
    task.wait(0.4)
    workspace.Camera.CameraSubject = FakeCharacter.Humanoid

    for _, limb in pairs(limbs) do
        local name, cf = unpack(limb)
        if name ~= "" then
            coroutine.wrap(function()
                local part = character:WaitForChild(name)
                local success, errorMessage = pcall(function()
                    Align(part.Handle, FakeCharacter[_], cf)
                end)
                if not success then
                    print(errorMessage)
                end
            end)()
        end
    end
end)
